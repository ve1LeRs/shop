{"ast":null,"code":"const _ = require('lodash');\nconst {\n  columnToLetter\n} = require('./utils');\nconst {\n  GoogleSpreadsheetFormulaError\n} = require('./errors');\nclass GoogleSpreadsheetCell {\n  constructor(parentSheet, rowIndex, columnIndex, cellData) {\n    this._sheet = parentSheet; // the parent GoogleSpreadsheetWorksheet instance\n    this._row = rowIndex;\n    this._column = columnIndex;\n    this._updateRawData(cellData);\n    return this;\n  }\n\n  // newData can be undefined/null if the cell is totally empty and unformatted\n  _updateRawData(newData = {}) {\n    this._rawData = newData;\n    this._draftData = {}; // stuff to save\n    this._error = null;\n    if (_.get(this._rawData, 'effectiveValue.errorValue')) {\n      this._error = new GoogleSpreadsheetFormulaError(this._rawData.effectiveValue.errorValue);\n    }\n  }\n\n  // CELL LOCATION/ADDRESS /////////////////////////////////////////////////////////////////////////\n  get rowIndex() {\n    return this._row;\n  }\n  get columnIndex() {\n    return this._column;\n  }\n  get a1Column() {\n    return columnToLetter(this._column + 1);\n  }\n  get a1Row() {\n    return this._row + 1;\n  } // a1 row numbers start at 1 instead of 0\n  get a1Address() {\n    return `${this.a1Column}${this.a1Row}`;\n  }\n\n  // CELL CONTENTS - VALUE/FORMULA/NOTES ///////////////////////////////////////////////////////////\n  get value() {\n    // const typeKey = _.keys(this._rawData.effectiveValue)[0];\n    if (this._draftData.value !== undefined) throw new Error('Value has been changed');\n    if (this._error) return this._error;\n    if (!this._rawData.effectiveValue) return null;\n    return _.values(this._rawData.effectiveValue)[0];\n  }\n  set value(newValue) {\n    if (_.isBoolean(newValue)) {\n      this._draftData.valueType = 'boolValue';\n    } else if (_.isString(newValue)) {\n      if (newValue.substr(0, 1) === '=') this._draftData.valueType = 'formulaValue';else this._draftData.valueType = 'stringValue';\n    } else if (_.isFinite(newValue)) {\n      this._draftData.valueType = 'numberValue';\n    } else if (_.isNil(newValue)) {\n      // null or undefined\n      this._draftData.valueType = 'stringValue';\n      newValue = '';\n    } else {\n      throw new Error('Set value to boolean, string, or number');\n    }\n    this._draftData.value = newValue;\n  }\n  get valueType() {\n    // an error only happens with a formula\n    if (this._error) return 'errorValue';\n    if (!this._rawData.effectiveValue) return null;\n    return _.keys(this._rawData.effectiveValue)[0];\n  }\n  get formattedValue() {\n    return this._rawData.formattedValue || null;\n  }\n  set formattedValue(newVal) {\n    throw new Error('You cannot modify the formatted value directly');\n  }\n  get formula() {\n    return _.get(this._rawData, 'userEnteredValue.formulaValue', null);\n  }\n  set formula(newValue) {\n    if (newValue.substr(0, 1) !== '=') throw new Error('formula must begin with \"=\"');\n    this.value = newValue; // use existing value setter\n  }\n  get formulaError() {\n    return this._error;\n  }\n  get hyperlink() {\n    if (this._draftData.value) throw new Error('Save cell to be able to read hyperlink');\n    return this._rawData.hyperlink;\n  }\n  set hyperlink(val) {\n    throw new Error('Do not set hyperlink directly. Instead set cell.formula, for example `cell.formula = \\'=HYPERLINK(\"http://google.com\", \"Google\")\\'`');\n  }\n  get note() {\n    return this._draftData.note !== undefined ? this._draftData.note : this._rawData.note;\n  }\n  set note(newVal) {\n    if (newVal === null || newVal === undefined) newVal = '';\n    if (!_.isString(newVal)) throw new Error('Note must be a string');\n    if (newVal === this._rawData.note) delete this._draftData.note;else this._draftData.note = newVal;\n  }\n\n  // CELL FORMATTING ///////////////////////////////////////////////////////////////////////////////\n  get userEnteredFormat() {\n    return this._rawData.userEnteredFormat;\n  }\n  get effectiveFormat() {\n    return this._rawData.effectiveFormat;\n  }\n  set userEnteredFormat(newVal) {\n    throw new Error('Do not modify directly, instead use format properties');\n  }\n  set effectiveFormat(newVal) {\n    throw new Error('Read-only');\n  }\n  _getFormatParam(param) {\n    // we freeze the object so users don't change nested props accidentally\n    // TODO: figure out something that would throw an error if you try to update it?\n    if (_.get(this._draftData, `userEnteredFormat.${param}`)) {\n      throw new Error('User format is unsaved - save the cell to be able to read it again');\n    }\n    return Object.freeze(this._rawData.userEnteredFormat[param]);\n  }\n  _setFormatParam(param, newVal) {\n    if (_.isEqual(newVal, _.get(this._rawData, `userEnteredFormat.${param}`))) {\n      _.unset(this._draftData, `userEnteredFormat.${param}`);\n    } else {\n      _.set(this._draftData, `userEnteredFormat.${param}`, newVal);\n      this._draftData.clearFormat = false;\n    }\n  }\n\n  // format getters\n  get numberFormat() {\n    return this._getFormatParam('numberFormat');\n  }\n  get backgroundColor() {\n    return this._getFormatParam('backgroundColor');\n  }\n  get borders() {\n    return this._getFormatParam('borders');\n  }\n  get padding() {\n    return this._getFormatParam('padding');\n  }\n  get horizontalAlignment() {\n    return this._getFormatParam('horizontalAlignment');\n  }\n  get verticalAlignment() {\n    return this._getFormatParam('verticalAlignment');\n  }\n  get wrapStrategy() {\n    return this._getFormatParam('wrapStrategy');\n  }\n  get textDirection() {\n    return this._getFormatParam('textDirection');\n  }\n  get textFormat() {\n    return this._getFormatParam('textFormat');\n  }\n  get hyperlinkDisplayType() {\n    return this._getFormatParam('hyperlinkDisplayType');\n  }\n  get textRotation() {\n    return this._getFormatParam('textRotation');\n  }\n\n  // format setters\n  set numberFormat(newVal) {\n    return this._setFormatParam('numberFormat', newVal);\n  }\n  set backgroundColor(newVal) {\n    return this._setFormatParam('backgroundColor', newVal);\n  }\n  set borders(newVal) {\n    return this._setFormatParam('borders', newVal);\n  }\n  set padding(newVal) {\n    return this._setFormatParam('padding', newVal);\n  }\n  set horizontalAlignment(newVal) {\n    return this._setFormatParam('horizontalAlignment', newVal);\n  }\n  set verticalAlignment(newVal) {\n    return this._setFormatParam('verticalAlignment', newVal);\n  }\n  set wrapStrategy(newVal) {\n    return this._setFormatParam('wrapStrategy', newVal);\n  }\n  set textDirection(newVal) {\n    return this._setFormatParam('textDirection', newVal);\n  }\n  set textFormat(newVal) {\n    return this._setFormatParam('textFormat', newVal);\n  }\n  set hyperlinkDisplayType(newVal) {\n    return this._setFormatParam('hyperlinkDisplayType', newVal);\n  }\n  set textRotation(newVal) {\n    return this._setFormatParam('textRotation', newVal);\n  }\n  clearAllFormatting() {\n    // need to track this separately since by setting/unsetting things, we may end up with\n    // this._draftData.userEnteredFormat as an empty object, but not an intent to clear it\n    this._draftData.clearFormat = true;\n    delete this._draftData.userEnteredFormat;\n  }\n\n  // SAVING + UTILS ////////////////////////////////////////////////////////////////////////////////\n\n  // returns true if there are any updates that have not been saved yet\n  get _isDirty() {\n    // have to be careful about checking undefined rather than falsy\n    // in case a new value is empty string or 0 or false\n    if (this._draftData.note !== undefined) return true;\n    if (_.keys(this._draftData.userEnteredFormat).length) return true;\n    if (this._draftData.clearFormat) return true;\n    if (this._draftData.value !== undefined) return true;\n    return false;\n  }\n  discardUnsavedChanges() {\n    this._draftData = {};\n  }\n  async save() {\n    await this._sheet.saveUpdatedCells([this]);\n  }\n\n  // used by worksheet when saving cells\n  // returns an individual batchUpdate request to update the cell\n  _getUpdateRequest() {\n    // this logic should match the _isDirty logic above\n    // but we need it broken up to build the request below\n    const isValueUpdated = this._draftData.value !== undefined;\n    const isNoteUpdated = this._draftData.note !== undefined;\n    const isFormatUpdated = !!_.keys(this._draftData.userEnteredFormat || {}).length;\n    const isFormatCleared = this._draftData.clearFormat;\n\n    // if no updates, we return null, which we can filter out later before sending requests\n    if (!_.some([isValueUpdated, isNoteUpdated, isFormatUpdated, isFormatCleared])) {\n      return null;\n    }\n\n    // build up the formatting object, which has some quirks...\n    const format = {\n      // have to pass the whole object or it will clear existing properties\n      ...this._rawData.userEnteredFormat,\n      ...this._draftData.userEnteredFormat\n    };\n    // if background color already set, cell has backgroundColor and backgroundColorStyle\n    // but backgroundColorStyle takes precendence so we must remove to set the color\n    // see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/cells#CellFormat\n    if (_.get(this._draftData, 'userEnteredFormat.backgroundColor')) {\n      delete format.backgroundColorStyle;\n    }\n    return {\n      updateCells: {\n        rows: [{\n          values: [{\n            ...(isValueUpdated && {\n              userEnteredValue: {\n                [this._draftData.valueType]: this._draftData.value\n              }\n            }),\n            ...(isNoteUpdated && {\n              note: this._draftData.note\n            }),\n            ...(isFormatUpdated && {\n              userEnteredFormat: format\n            }),\n            ...(isFormatCleared && {\n              userEnteredFormat: {}\n            })\n          }]\n        }],\n        // turns into a string of which fields to update ex \"note,userEnteredFormat\"\n        fields: _.keys(_.pickBy({\n          userEnteredValue: isValueUpdated,\n          note: isNoteUpdated,\n          userEnteredFormat: isFormatUpdated || isFormatCleared\n        })).join(','),\n        start: {\n          sheetId: this._sheet.sheetId,\n          rowIndex: this.rowIndex,\n          columnIndex: this.columnIndex\n        }\n      }\n    };\n  }\n}\nmodule.exports = GoogleSpreadsheetCell;","map":{"version":3,"names":["_","require","columnToLetter","GoogleSpreadsheetFormulaError","GoogleSpreadsheetCell","constructor","parentSheet","rowIndex","columnIndex","cellData","_sheet","_row","_column","_updateRawData","newData","_rawData","_draftData","_error","get","effectiveValue","errorValue","a1Column","a1Row","a1Address","value","undefined","Error","values","newValue","isBoolean","valueType","isString","substr","isFinite","isNil","keys","formattedValue","newVal","formula","formulaError","hyperlink","val","note","userEnteredFormat","effectiveFormat","_getFormatParam","param","Object","freeze","_setFormatParam","isEqual","unset","set","clearFormat","numberFormat","backgroundColor","borders","padding","horizontalAlignment","verticalAlignment","wrapStrategy","textDirection","textFormat","hyperlinkDisplayType","textRotation","clearAllFormatting","_isDirty","length","discardUnsavedChanges","save","saveUpdatedCells","_getUpdateRequest","isValueUpdated","isNoteUpdated","isFormatUpdated","isFormatCleared","some","format","backgroundColorStyle","updateCells","rows","userEnteredValue","fields","pickBy","join","start","sheetId","module","exports"],"sources":["C:/Users/79818/shop1/node_modules/google-spreadsheet/lib/GoogleSpreadsheetCell.js"],"sourcesContent":["const _ = require('lodash');\n\nconst { columnToLetter } = require('./utils');\n\nconst { GoogleSpreadsheetFormulaError } = require('./errors');\n\nclass GoogleSpreadsheetCell {\n  constructor(parentSheet, rowIndex, columnIndex, cellData) {\n    this._sheet = parentSheet; // the parent GoogleSpreadsheetWorksheet instance\n    this._row = rowIndex;\n    this._column = columnIndex;\n\n    this._updateRawData(cellData);\n    return this;\n  }\n\n  // newData can be undefined/null if the cell is totally empty and unformatted\n  _updateRawData(newData = {}) {\n    this._rawData = newData;\n    this._draftData = {}; // stuff to save\n    this._error = null;\n    if (_.get(this._rawData, 'effectiveValue.errorValue')) {\n      this._error = new GoogleSpreadsheetFormulaError(this._rawData.effectiveValue.errorValue);\n    }\n  }\n\n  // CELL LOCATION/ADDRESS /////////////////////////////////////////////////////////////////////////\n  get rowIndex() { return this._row; }\n  get columnIndex() { return this._column; }\n  get a1Column() { return columnToLetter(this._column + 1); }\n  get a1Row() { return this._row + 1; } // a1 row numbers start at 1 instead of 0\n  get a1Address() { return `${this.a1Column}${this.a1Row}`; }\n\n  // CELL CONTENTS - VALUE/FORMULA/NOTES ///////////////////////////////////////////////////////////\n  get value() {\n    // const typeKey = _.keys(this._rawData.effectiveValue)[0];\n    if (this._draftData.value !== undefined) throw new Error('Value has been changed');\n    if (this._error) return this._error;\n    if (!this._rawData.effectiveValue) return null;\n    return _.values(this._rawData.effectiveValue)[0];\n  }\n\n  set value(newValue) {\n    if (_.isBoolean(newValue)) {\n      this._draftData.valueType = 'boolValue';\n    } else if (_.isString(newValue)) {\n      if (newValue.substr(0, 1) === '=') this._draftData.valueType = 'formulaValue';\n      else this._draftData.valueType = 'stringValue';\n    } else if (_.isFinite(newValue)) {\n      this._draftData.valueType = 'numberValue';\n    } else if (_.isNil(newValue)) {\n      // null or undefined\n      this._draftData.valueType = 'stringValue';\n      newValue = '';\n    } else {\n      throw new Error('Set value to boolean, string, or number');\n    }\n    this._draftData.value = newValue;\n  }\n\n  get valueType() {\n    // an error only happens with a formula\n    if (this._error) return 'errorValue';\n    if (!this._rawData.effectiveValue) return null;\n    return _.keys(this._rawData.effectiveValue)[0];\n  }\n\n  get formattedValue() { return this._rawData.formattedValue || null; }\n  set formattedValue(newVal) {\n    throw new Error('You cannot modify the formatted value directly');\n  }\n\n  get formula() { return _.get(this._rawData, 'userEnteredValue.formulaValue', null); }\n  set formula(newValue) {\n    if (newValue.substr(0, 1) !== '=') throw new Error('formula must begin with \"=\"');\n    this.value = newValue; // use existing value setter\n  }\n  get formulaError() { return this._error; }\n\n  get hyperlink() {\n    if (this._draftData.value) throw new Error('Save cell to be able to read hyperlink');\n    return this._rawData.hyperlink;\n  }\n  set hyperlink(val) {\n    throw new Error('Do not set hyperlink directly. Instead set cell.formula, for example `cell.formula = \\'=HYPERLINK(\"http://google.com\", \"Google\")\\'`');\n  }\n\n  get note() {\n    return this._draftData.note !== undefined ? this._draftData.note : this._rawData.note;\n  }\n\n  set note(newVal) {\n    if (newVal === null || newVal === undefined) newVal = '';\n    if (!_.isString(newVal)) throw new Error('Note must be a string');\n    if (newVal === this._rawData.note) delete this._draftData.note;\n    else this._draftData.note = newVal;\n  }\n\n  // CELL FORMATTING ///////////////////////////////////////////////////////////////////////////////\n  get userEnteredFormat() { return this._rawData.userEnteredFormat; }\n  get effectiveFormat() { return this._rawData.effectiveFormat; }\n  set userEnteredFormat(newVal) { throw new Error('Do not modify directly, instead use format properties'); }\n  set effectiveFormat(newVal) { throw new Error('Read-only'); }\n\n  _getFormatParam(param) {\n    // we freeze the object so users don't change nested props accidentally\n    // TODO: figure out something that would throw an error if you try to update it?\n    if (_.get(this._draftData, `userEnteredFormat.${param}`)) {\n      throw new Error('User format is unsaved - save the cell to be able to read it again');\n    }\n    return Object.freeze(this._rawData.userEnteredFormat[param]);\n  }\n\n  _setFormatParam(param, newVal) {\n    if (_.isEqual(newVal, _.get(this._rawData, `userEnteredFormat.${param}`))) {\n      _.unset(this._draftData, `userEnteredFormat.${param}`);\n    } else {\n      _.set(this._draftData, `userEnteredFormat.${param}`, newVal);\n      this._draftData.clearFormat = false;\n    }\n  }\n\n  // format getters\n  get numberFormat() { return this._getFormatParam('numberFormat'); }\n  get backgroundColor() { return this._getFormatParam('backgroundColor'); }\n  get borders() { return this._getFormatParam('borders'); }\n  get padding() { return this._getFormatParam('padding'); }\n  get horizontalAlignment() { return this._getFormatParam('horizontalAlignment'); }\n  get verticalAlignment() { return this._getFormatParam('verticalAlignment'); }\n  get wrapStrategy() { return this._getFormatParam('wrapStrategy'); }\n  get textDirection() { return this._getFormatParam('textDirection'); }\n  get textFormat() { return this._getFormatParam('textFormat'); }\n  get hyperlinkDisplayType() { return this._getFormatParam('hyperlinkDisplayType'); }\n  get textRotation() { return this._getFormatParam('textRotation'); }\n\n  // format setters\n  set numberFormat(newVal) { return this._setFormatParam('numberFormat', newVal); }\n  set backgroundColor(newVal) { return this._setFormatParam('backgroundColor', newVal); }\n  set borders(newVal) { return this._setFormatParam('borders', newVal); }\n  set padding(newVal) { return this._setFormatParam('padding', newVal); }\n  set horizontalAlignment(newVal) { return this._setFormatParam('horizontalAlignment', newVal); }\n  set verticalAlignment(newVal) { return this._setFormatParam('verticalAlignment', newVal); }\n  set wrapStrategy(newVal) { return this._setFormatParam('wrapStrategy', newVal); }\n  set textDirection(newVal) { return this._setFormatParam('textDirection', newVal); }\n  set textFormat(newVal) { return this._setFormatParam('textFormat', newVal); }\n  set hyperlinkDisplayType(newVal) { return this._setFormatParam('hyperlinkDisplayType', newVal); }\n  set textRotation(newVal) { return this._setFormatParam('textRotation', newVal); }\n\n  clearAllFormatting() {\n    // need to track this separately since by setting/unsetting things, we may end up with\n    // this._draftData.userEnteredFormat as an empty object, but not an intent to clear it\n    this._draftData.clearFormat = true;\n    delete this._draftData.userEnteredFormat;\n  }\n\n  // SAVING + UTILS ////////////////////////////////////////////////////////////////////////////////\n\n  // returns true if there are any updates that have not been saved yet\n  get _isDirty() {\n    // have to be careful about checking undefined rather than falsy\n    // in case a new value is empty string or 0 or false\n    if (this._draftData.note !== undefined) return true;\n    if (_.keys(this._draftData.userEnteredFormat).length) return true;\n    if (this._draftData.clearFormat) return true;\n    if (this._draftData.value !== undefined) return true;\n    return false;\n  }\n\n  discardUnsavedChanges() {\n    this._draftData = {};\n  }\n\n  async save() {\n    await this._sheet.saveUpdatedCells([this]);\n  }\n\n  // used by worksheet when saving cells\n  // returns an individual batchUpdate request to update the cell\n  _getUpdateRequest() {\n    // this logic should match the _isDirty logic above\n    // but we need it broken up to build the request below\n    const isValueUpdated = this._draftData.value !== undefined;\n    const isNoteUpdated = this._draftData.note !== undefined;\n    const isFormatUpdated = !!_.keys(this._draftData.userEnteredFormat || {}).length;\n    const isFormatCleared = this._draftData.clearFormat;\n\n    // if no updates, we return null, which we can filter out later before sending requests\n    if (!_.some([isValueUpdated, isNoteUpdated, isFormatUpdated, isFormatCleared])) {\n      return null;\n    }\n\n    // build up the formatting object, which has some quirks...\n    const format = {\n      // have to pass the whole object or it will clear existing properties\n      ...this._rawData.userEnteredFormat,\n      ...this._draftData.userEnteredFormat,\n    };\n    // if background color already set, cell has backgroundColor and backgroundColorStyle\n    // but backgroundColorStyle takes precendence so we must remove to set the color\n    // see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/cells#CellFormat\n    if (_.get(this._draftData, 'userEnteredFormat.backgroundColor')) {\n      delete (format.backgroundColorStyle);\n    }\n\n    return {\n      updateCells: {\n        rows: [{\n          values: [{\n            ...isValueUpdated && {\n              userEnteredValue: { [this._draftData.valueType]: this._draftData.value },\n            },\n            ...isNoteUpdated && {\n              note: this._draftData.note,\n            },\n            ...isFormatUpdated && {\n              userEnteredFormat: format,\n            },\n            ...isFormatCleared && {\n              userEnteredFormat: {},\n            },\n          }],\n        }],\n        // turns into a string of which fields to update ex \"note,userEnteredFormat\"\n        fields: _.keys(_.pickBy({\n          userEnteredValue: isValueUpdated,\n          note: isNoteUpdated,\n          userEnteredFormat: isFormatUpdated || isFormatCleared,\n        })).join(','),\n        start: {\n          sheetId: this._sheet.sheetId,\n          rowIndex: this.rowIndex,\n          columnIndex: this.columnIndex,\n        },\n      },\n    };\n  }\n}\n\nmodule.exports = GoogleSpreadsheetCell;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}